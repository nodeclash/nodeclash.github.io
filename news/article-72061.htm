<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://nodeclash.github.io/news/article-72061.htm" />
    <!-- ========== Meta Tags ========== -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <!-- ========== Page Title ========== -->
    <title>使用feign客户端要使用注解@EnableFeignClients</title>
        <meta name="description" content="概述 在Spring cloud应用中，当我们要使用feign客户端时，一般要做以下三件事情 : 1使用注解@EnableFeignClients启用feign客户端； 示例 : @SpringBoo" />
        <link rel="icon" href="/assets/website/img/nodeclash/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="NodeClash节点订阅站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://nodeclash.github.io/news/article-72061.htm" />
    <meta property="og:site_name" content="NodeClash节点订阅站" />
    <meta property="og:title" content="使用feign客户端要使用注解@EnableFeignClients" />
    <meta property="og:image" content="https://nodeclash.github.io/uploads/20240306/c351eb5631af2891637567b0876ec4e1.webp" />
        <meta property="og:release_date" content="2025-03-12T06:07:11" />
    <meta property="og:updated_time" content="2025-03-12T06:07:11" />
        <meta property="og:description" content="概述 在Spring cloud应用中，当我们要使用feign客户端时，一般要做以下三件事情 : 1使用注解@EnableFeignClients启用feign客户端； 示例 : @SpringBoo" />
        
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="使用feign客户端要使用注解@EnableFeignClients">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">

    <!-- ========== Start Stylesheet ========== -->
    <link href="/assets/website/css/nodeclash/bootstrap.min.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/font-awesome.min.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/themify-icons.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/flaticon-set.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/elegant-icons.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/magnific-popup.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/owl.carousel.min.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/owl.theme.default.min.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/animate.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/bootsnav.css" rel="stylesheet" />
    <link href="/assets/website/css/nodeclash/style.css" rel="stylesheet">
    <link href="/assets/website/css/nodeclash/responsive.css" rel="stylesheet" />
    <!-- ========== End Stylesheet ========== -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="/assets/website/js/frontend/nodeclash/html5/html5shiv.min.js"></script>
      <script src="/assets/website/js/frontend/nodeclash/html5/respond.min.js"></script>
    <![endif]-->

    <!-- ========== Google Fonts ========== -->
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800&display=swap" rel="stylesheet">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7S1CLRGCWE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7S1CLRGCWE');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!-- Header 
    ============================================= -->
    <header id="home">

        <!-- Start Navigation -->
        <nav class="navbar navbar-default attr-border navbar-sticky dark bootsnav">

            <div class="container-full">
                <!-- Start Header Navigation -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-menu">
                        <i class="fa fa-bars"></i>
                    </button>
                    <a class="navbar-brand" href="/">
                            <img src="/assets/website/img/nodeclash/logo-s.png" class="logo" alt="Logo">
                            Node Clash                    </a>
                </div>
                <!-- End Header Navigation -->

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="navbar-menu">
                    <ul class="nav navbar-nav navbar-right" data-in="fadeInDown" data-out="fadeOutUp">
                                                <li>
                            <a href="/">首页</a>
                        </li>
                                                <li>
                            <a href="/free-nodes/">免费节点</a>
                        </li>
                                                <li>
                            <a href="/paid-subscribe/">推荐机场</a>
                        </li>
                                                <li>
                            <a href="/client.htm">客户端</a>
                        </li>
                                                <li>
                            <a href="/news/">新闻资讯</a>
                        </li>
                                            </ul>
                </div><!-- /.navbar-collapse -->
            </div>

        </nav>
        <!-- End Navigation -->

    </header>
    <!-- End Header -->
    <!-- Start Breadcrumb 
    ============================================= -->
    <div class="breadcrumb-area bg-gray text-center shadow dark text-light bg-cover" style="background-image: url(/assets/website/img/nodeclash/banner/26.jpg);">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 offset-lg-2">
                    <h1 style="word-break: break-all;">使用feign客户端要使用注解@EnableFeignClients</h1>
                    <ul class="breadcrumb">
                        <li><a href="/"><i class="fas fa-home"></i> 首页</a></li>
                        <li><a href="/news/"> 新闻资讯</a></li>
                        <li class="active">正文</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <!-- End Breadcrumb -->
    <!-- Start Blog
    ============================================= -->
    <div class="blog-area single full-blog full-blog default-padding">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                    <div class="blog-items">
                        <div class="row">
                            <div class="blog-content col-lg-10 offset-lg-1 col-md-12">
                                <div class="item">
                                    <div class="blog-item-box">
                                        <!-- Start Post Thumb -->
                                        <div class="content">
                                                            <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <p>概述<br /> 在Spring cloud应用中，当我们要使用feign客户端时，一般要做以下三件事情 :</p> <p>1使用注解@EnableFeignClients启用feign客户端；<br /> 示例 :</p> <p>@SpringBootApplication<br /> @EnableFeignClients<br /> public class TestApplication {<!-- --><br /> &nbsp; &nbsp; public static void main(String[] args) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; SpringApplication.run(TestApplication.class, args);<br /> &nbsp; &nbsp; }<br /> }</p> <p> 2使用注解@FeignClient 定义feign客户端 ;<br /> 示例 : 该例子定义了一个feign客户端，将远程服务http://test-service/test/echo映射为一个本地Java方法调用。</p> <p>@FeignClient(name = "test-service", path = "/test")<br /> public interface TestService {<!-- --><br /> &nbsp; &nbsp; @RequestMapping(value = "/echo", method = RequestMethod.GET)<br /> &nbsp; &nbsp; TestModel echo(@RequestParam("parameter") String parameter);<br /> }</p> <p> 3使用注解@Autowired使用上面所定义feign的客户端 ；</p> <p>&nbsp; &nbsp; @Autowired<br /> &nbsp; &nbsp; TestService testService;</p> <p>&nbsp; &nbsp; public void run()<br /> &nbsp; &nbsp; {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; // 这里的使用本地Java API的方式调用远程的Restful接口<br /> &nbsp; &nbsp; &nbsp; &nbsp; TestModel dto = testService.echo("Hello,你好!");<br /> &nbsp; &nbsp; &nbsp; &nbsp; log.info("echo : {}", dto);<br /> &nbsp; &nbsp; &nbsp;}</p> <p> 上面的三个步骤，前两个步骤可以理解为定义feign客户端,第三步是使用所定义的feign客户端。通过调试发现，上面第三步所注入的testService是一个代理对象，如下所示 :</p> <p>testService = {$Proxy66@5502}<br /> &nbsp;&nbsp; &nbsp;"HardCodedTarget(type=TestService, name=test-service, url=http://test-service/test)"<br /> &nbsp;h = {ReflectiveFeign$FeignInvocationHandler@6924}<br /> &nbsp; target = {Target$HardCodedTarget@6930}<br /> &nbsp; dispatch = {LinkedHashMap@6931} &nbsp;size = 1<br /> &nbsp; &nbsp;0 = {LinkedHashMap$Entry@6948}<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"public abstract xxx.model.TestModel xxx.service.TestService.echo(java.lang.String)"</p> <p> 该对象会代理客户端完成远程服务方法的调用，那么，该代理对象是如何生成的 ？这篇文章，我们通过源代码分析来回答这些问题。</p> <p>源代码解析<br /> 源代码版本 : spring-cloud-openfeign-core-2.1.0.RELEASE , Spring Cloud Greenwich.RELEASE</p> <p>注解@EnableFeignClients:扫描和注册feign客户端bean定义<br /> 注解@EnableFeignClients告诉框架扫描所有使用注解@FeignClient定义的feign客户端。它又通过注解@Import导入了类FeignClientsRegistrar( feign客户端注册器),如下所示:</p> <p>@EnableFeignClients<br /> &nbsp;&nbsp; &nbsp;=&gt; @Import(FeignClientsRegistrar.class)</p> <p> 那么 FeignClientsRegistrar 又是做什么的呢 ？我们继续。</p> <p>FeignClientsRegistrar : feign客户端注册器<br /> FeignClientsRegistrar实现了接口 ImportBeanDefinitionRegistrar。而ImportBeanDefinitionRegistrar的设计目的，就是被某个实现类实现，配合使用@Configuration注解的使用者配置类，在配置类被处理时，用于额外注册一部分bean定义:</p> <p>对于上面的例子，使用者配置类就是 TestApplication</p> <p>public interface ImportBeanDefinitionRegistrar {<!-- --></p> <p>&nbsp; &nbsp;/**<br /> &nbsp; &nbsp; * Register bean definitions as necessary based on the given annotation metadata of<br /> &nbsp; &nbsp; * the importing @Configuration class.<br /> &nbsp; &nbsp; * 根据使用者配置类的注解元数据注册bean定义<br /> &nbsp; &nbsp; * @param importingClassMetadata 使用者配置类的注解元数据<br /> &nbsp; &nbsp; * @param registry 当前bean定义注册表，一般指当前Spring应用上下文对象，当前Spring容器<br /> &nbsp; &nbsp; */<br /> &nbsp; &nbsp;public void registerBeanDefinitions(<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);</p> <p>}</p> <p> #registerBeanDefinitions – 注册feign客户端配置和feign客户端<br /> 方法FeignClientsRegistrar#registerBeanDefinitions实现如下:</p> <p>&nbsp; &nbsp;@Override<br /> &nbsp; &nbsp;public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {<!-- --><br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 注册缺省配置到容器 registry<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerDefaultConfiguration(metadata, registry);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 注册所发现的各个 feign 客户端到到容器 registry<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerFeignClients(metadata, registry);<br /> &nbsp; &nbsp;}</p> <p> #registerDefaultConfiguration– 注册feign客户端缺省配置<br /> &nbsp;&nbsp; &nbsp;// 注册feign客户端的缺省配置，缺省配置信息来自注解元数据的属性 defaultConfiguration<br /> &nbsp; &nbsp; private void registerDefaultConfiguration(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 获取注解@EnableFeignClients的注解属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; defaultAttrs = metadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(EnableFeignClients.class.getName(), true);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (defaultAttrs != null &amp;&amp; defaultAttrs.containsKey("defaultConfiguration")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 下面是对所注册的缺省配置的的命名，格式如下 :<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// default.xxx.TestApplication<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (metadata.hasEnclosingClass()) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// &nbsp;针对注解元数据metadata对应一个内部类或者方法返回的方法本地类的情形<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name = "default." + metadata.getEnclosingClassName();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else {<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// name 举例 : default.xxx.TestApplication<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 这里 xxx.TestApplication 是注解@EnableFeignClients所在配置类的长名称<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name = "default." + metadata.getClassName();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 各种信息准备就绪，现在执行注册<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerClientConfiguration(registry, name,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;defaultAttrs.get("defaultConfiguration"));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;}</p> <p> #registerDefaultConfiguration方法最终注册客户端缺省配置的动作交给方法#registerClientConfiguration执行。</p> <p>#registerClientConfiguration – 注册feign客户端配置<br /> &nbsp; &nbsp; // 将指定feign客户端配置configuration作为一个bean定义注册到容器：<br /> &nbsp; &nbsp; // bean 定义对象类型 : GenericBeanDefinition<br /> &nbsp; &nbsp; // bean class : FeignClientSpecification<br /> &nbsp; &nbsp; // bean name : default.xxx.TestApplication.FeignClientSpecification (缺省配置)<br /> &nbsp; &nbsp; // bean name : test-service.FeignClientSpecification (针对某个feign client 的配置)<br /> &nbsp;&nbsp; &nbsp;private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Object configuration) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionBuilder builder = BeanDefinitionBuilder<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.genericBeanDefinition(FeignClientSpecification.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 设置构造函数参数<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.addConstructorArgValue(name);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.addConstructorArgValue(configuration);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从bean定义构建器构造bean定义并注册到容器<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registry.registerBeanDefinition(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name + "." + FeignClientSpecification.class.getSimpleName(),<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.getBeanDefinition());<br /> &nbsp;&nbsp; &nbsp;}</p> <p> #registerClientConfiguration方法用于注册一个feign客户端配置bean,可以用于注册针对所有feign客户端的缺省配置的注册，也可以用于针对每个feign客户端的专有配置的注册。</p> <p>针对所有feign客户端的缺省配置的bean名称类似于 : default.xxx.TestApplication.FeignClientSpecification，<br /> 针对某个名称为test-service的feign客户端的配置的bean名称类似于:test-service.FeignClientSpecification。</p> <p>#registerFeignClients – 注册各个feign客户端及其配置<br /> &nbsp;&nbsp; &nbsp;// 参数 metadata : 注解@EnableFeignClients所在配置类的注解元数据<br /> &nbsp;&nbsp; &nbsp;public void registerFeignClients(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 定义一个基于classpath的组件扫描器，它会根据指定的扫描位置和@EnableFeignClients注解属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 找出开发人员定义的所有feign客户端，也就是那些使用了注解@FeignClient的所有接口定义<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ClassPathScanningCandidateComponentProvider scanner = getScanner();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;scanner.setResourceLoader(this.resourceLoader);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Set&lt;String&gt; basePackages;</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// attrs 用于表示注解@EnableFeignClients所在配置类的注解元数据中注解@EnableFeignClients<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 的部分<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; attrs = metadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(EnableFeignClients.class.getName());<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignClient.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;final Class&lt;?&gt;[] clients = attrs == null ? null<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;: (Class&lt;?&gt;[]) attrs.get("clients");<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (clients == null || clients.length == 0) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// @EnableFeignClients 中没有指定 clients 属性的情况<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;scanner.addIncludeFilter(annotationTypeFilter);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages = getBasePackages(metadata);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// @EnableFeignClients 中指定了 clients 属性的情况<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;final Set&lt;String&gt; clientClasses = new HashSet&lt;&gt;();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages = new HashSet&lt;&gt;();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (Class&lt;?&gt; clazz : clients) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(ClassUtils.getPackageName(clazz));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;clientClasses.add(clazz.getCanonicalName());<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;@Override<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;protected boolean match(ClassMetadata metadata) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String cleaned = metadata.getClassName().replaceAll("\\$", ".");<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return clientClasses.contains(cleaned);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;};<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;scanner.addIncludeFilter(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 使用 scanner 扫描每一个 basePackage, 获取其中的 feign 客户端定义，<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 也就是 @FeignClient 定义的那些接口<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (String basePackage : basePackages) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Set&lt;BeanDefinition&gt; candidateComponents = scanner<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.findCandidateComponents(basePackage);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (BeanDefinition candidateComponent : candidateComponents) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (candidateComponent instanceof AnnotatedBeanDefinition) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// verify annotated class is an interface<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Assert.isTrue(annotationMetadata.isInterface(),<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"@FeignClient can only be specified on an interface");</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 获取所定义的feign客户端接口上的注解@FeignClient属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; attributes = annotationMetadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignClient.class.getCanonicalName());</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name = getClientName(attributes);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 将所定义的feign客户端上的配置属性作为一个bean注册到容器<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 此方法的逻辑我们上面已经分析过<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerClientConfiguration(registry, name,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;attributes.get("configuration"));</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 将所定义的feign客户端作为一个bean注册到容器：<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// bean 定义类型 : GenericBeanDefinition<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// &nbsp;bean class : FeignClientFactoryBean<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// &nbsp;autowire 模式 : 根据类型绑定<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// @FeignClient注解中的url,path,fallback等属性会设置为bean定义的属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerFeignClient(registry, annotationMetadata, attributes);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;// 辅助工具类，从@EnableFeignClients注解属性中获取basePackages属性:<br /> &nbsp;&nbsp; &nbsp;// 参考以下@EnableFeignClients注解属性 :<br /> &nbsp;&nbsp; &nbsp;// 1. value<br /> &nbsp;&nbsp; &nbsp;// 2. basePackages<br /> &nbsp;&nbsp; &nbsp;// 3. basePackageClasses<br /> &nbsp;&nbsp; &nbsp;// 4. 配置类所在的包<br /> &nbsp;&nbsp; &nbsp;// 参数 importingClassMetadata : 使用注解@EnableFeignClients的配置类的元数据<br /> &nbsp;&nbsp; &nbsp;protected Set&lt;String&gt; getBasePackages(AnnotationMetadata importingClassMetadata) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 注解@EnableFeignClients的属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; attributes = importingClassMetadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(EnableFeignClients.class.getCanonicalName());</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Set&lt;String&gt; basePackages = new HashSet&lt;&gt;();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (String pkg : (String[]) attributes.get("value")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(pkg)) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(pkg);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (String pkg : (String[]) attributes.get("basePackages")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(pkg)) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(pkg);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (Class&lt;?&gt; clazz : (Class[]) attributes.get("basePackageClasses")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(ClassUtils.getPackageName(clazz));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (basePackages.isEmpty()) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ClassUtils.getPackageName(importingClassMetadata.getClassName()));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return basePackages;<br /> &nbsp;&nbsp; &nbsp;}</p> <p> #registerFeignClients 最终注册feign客户端配置的动作交给#registerClientConfiguration完成，而注册feign客户端的动作交给#registerFeignClient方法完成。</p> <p>#registerFeignClient – 注册一个feign客户端<br /> &nbsp;&nbsp; &nbsp;// 将所定义的feign客户端作为一个bean注册到容器：<br /> &nbsp;&nbsp; &nbsp;// bean 定义类型 : GenericBeanDefinition<br /> &nbsp;&nbsp; &nbsp;// &nbsp;bean class : FeignClientFactoryBean -- 这是一个工厂bean，而不是最终bean实例的class<br /> &nbsp;&nbsp; &nbsp;// &nbsp;autowire 模式 : 根据类型绑定<br /> &nbsp;&nbsp; &nbsp;// @FeignClient注解中的url,path,fallback等属性会设置为bean定义的属性<br /> &nbsp;&nbsp; &nbsp;// 参数 registry : Spring 容器<br /> &nbsp;&nbsp; &nbsp;// 参数 annotationMetadata : @FeignClient所注解的接口上的注解元数据<br /> &nbsp;&nbsp; &nbsp;// 参数 attributes : @FeignClient 注解属性信息<br /> &nbsp;&nbsp; &nbsp;private void registerFeignClient(BeanDefinitionRegistry registry,<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {<!-- --><br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String className = annotationMetadata.getClassName();<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionBuilder definition = BeanDefinitionBuilder<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.genericBeanDefinition(FeignClientFactoryBean.class);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;validate(attributes);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("url", getUrl(attributes));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("path", getPath(attributes));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name = getName(attributes);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("name", name);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("type", className);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("decode404", attributes.get("decode404"));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("fallback", attributes.get("fallback"));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String alias = name + "FeignClient";<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean primary = (Boolean)attributes.get("primary"); // has a default, won't be null</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;beanDefinition.setPrimary(primary);</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String qualifier = getQualifier(attributes);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(qualifier)) {<!-- --><br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;alias = qualifier;<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;new String[] { alias });<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);<br /> &nbsp; &nbsp;}</p> <p> 从上面的代码分析可知，FeignClientsRegistrar的主要作用如下 :</p> <p>注册缺省feign客户端配置bean定义；<br /> 对于每个@FeignClient注解的feign客户端定义 :<br /> 注册一个针对该feign客户端的配置bean定义；<br /> 注册该feign客户端bean定义,指定生成bean实例采用工厂类FeignClientFactoryBean;<br /> 而且，上述功能实现在类方法FeignClientsRegistrar#registerBeanDefinitions中，这是接口ImportBeanDefinitionRegistrar所定义的方法。该方法会在@EnableFeignClients注解被处理时执行。具体的执行时调用栈如下所示：</p> <p>&nbsp; &nbsp; AbstractApplicationContext#invokeBeanFactoryPostProcessors<br /> &nbsp; &nbsp; =&gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors<br /> &nbsp; &nbsp; =&gt; foreach BeanDefinitionRegistryPostProcessor : #postProcessBeanDefinitionRegistry<br /> &nbsp; &nbsp; =&gt; ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry<br /> &nbsp; &nbsp; =&gt; #processConfigBeanDefinitions<br /> &nbsp; &nbsp; =&gt; ConfigurationClassBeanDefinitionReader#loadBeanDefinitions<br /> &nbsp; &nbsp; =&gt; foreach ConfigurationClass : #loadBeanDefinitionsForConfigurationClass<br /> &nbsp; &nbsp; =&gt; #loadBeanDefinitionsFromRegistrars<br /> &nbsp; &nbsp; =&gt; foreach ImportBeanDefinitionRegistrar : #registerBeanDefinitions<br /> &nbsp; &nbsp; =&gt; FeignClientsRegistrar#registerBeanDefinitions</p> <p> FeignClientFactoryBean生成feign客户端代理对象<br /> 基于上面的分析，我们可以得知，开发人员所定义的feign客户端和相关配置会以bean定义的形式注册到bean容器中，这样当使用@Autowired注入一个feign客户端时，容器会使用工厂类FeignClientFactoryBean为其生成一个实例。下面我们来看其具体工作过程。</p> <p>FeignClientFactoryBean#getObject生成feign客户端代理对象<br /> &nbsp; &nbsp; // 该方法由接口FactoryBean约定<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;@Override<br /> &nbsp;&nbsp; &nbsp;public Object getObject() throws Exception {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return getTarget();<br /> &nbsp;&nbsp; &nbsp;}</p> <p> &nbsp;&nbsp; &nbsp;&lt;T&gt; T getTarget() {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;从应用上下文中获取创建 feign 客户端的上下文对象 FeignContext<br /> &nbsp; &nbsp; &nbsp; &nbsp; // FeignContext 针对每个feign客户端定义会生成一个不同的 AnnotationConfigApplicationContext，<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 这些应用上下文的parent都设置为当前应用的主应用上下文<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 参考 : FeignAutoConfiguration<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignContext context = applicationContext.getBean(FeignContext.class);<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 为目标feign客户端对象构建一个 builder,该builder最终生成的目标feign客户端是一个<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 动态代理，使用 InvocationHandler ： ReflectiveFeign$FeignInvocationHandler<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Feign.Builder builder = feign(context);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!StringUtils.hasText(this.url)) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// @FeignClient 属性 url 属性没有指定的情况<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 根据属性 name , path 拼装一个 url，<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这种通常是需要在多个服务节点之间进行负载均衡的情况<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!this.name.startsWith("http")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url = "http://" + this.name;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url = this.name;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 方法cleanPath()加工属性path，使其以/开头，不以/结尾<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url += cleanPath();<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这里形成的url格式类似 : &nbsp;http://test-service/test<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 其中 test-service 是服务名，不是服务所在节点的IP，主机名或者域名</p> <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 函数 loadBalance 做如下动作 :<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 1. 将builder和一个LoadBalancerFeignClient bean实例关联起来<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 2. 使用一个HystrixTargeter将builder和一个 HardCodedTarget bean实例关联起来<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这里 HardCodedTarget 表示对应 url 为 http://test-service/test 的远程服务(可能<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 包含多个服务方法)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 3. 生成最终的feign client 实例 : ReflectiveFeign$FeignInvocationHandler 的动态代理对象，<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 使用 InvocationHandler ： ReflectiveFeign$FeignInvocationHandler。<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 每个远程服务方法会对应到一个@FeignClient注解的接口方法上(依据方法上的注解进行匹配)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (T) loadBalance(builder, context, new HardCodedTarget&lt;&gt;(this.type,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.name, url));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p> &nbsp; &nbsp; &nbsp; &nbsp; // @FeignClient 属性 url 属性被指定的情况<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 这种通常是明确指出了服务节点的url的情况，实际上不需要负载均衡<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(this.url) &amp;&amp; !this.url.startsWith("http")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.url = "http://" + this.url;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String url = this.url + cleanPath();<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 将builder和一个LoadBalancerFeignClient bean实例关联起来<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Client client = getOptional(context, Client.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (client != null) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (client instanceof LoadBalancerFeignClient) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// not load balancing because we have a url,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// but ribbon is on the classpath, so unwrap<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 因为指定了明确的服务节点url，所以这里不需要负载均衡，<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 所以这里尽管client是LoadBalancerFeignClient，所以<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 实际上可以获取其所代理的对象作为最终的client，<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 相当于去掉了LoadBalancerFeignClient这层的代理功能<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;client = ((LoadBalancerFeignClient)client).getDelegate();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.client(client);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 使用一个HystrixTargeter将builder和一个 HardCodedTarget bean实例关联起来<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Targeter targeter = get(context, Targeter.class);<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 生成最终的feign client 实例 : ReflectiveFeign$FeignInvocationHandler 的动态代理对象，<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 使用 InvocationHandler ： ReflectiveFeign$FeignInvocationHandler。<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 每个远程服务方法会对应到 一个@FeignClient注解的接口方法上(依据方法上的注解进行匹配)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (T) targeter.target(this, builder, context, new HardCodedTarget&lt;&gt;(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.type, this.name, url));<br /> &nbsp;&nbsp; &nbsp;}</p> <p> 方法FeignClientFactoryBean#feign – 创建feign客户端构建器<br /> protected Feign.Builder feign(FeignContext context) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Logger logger = loggerFactory.create(this.type);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从上下文获取一个 Feign.Builder 上,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 并从上下文获得 Encoder, Decoder, Contract 设置到该 builder 上<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Feign.Builder builder = get(context, Feign.Builder.class)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// required values<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.logger(logger)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.encoder(get(context, Encoder.class))<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.decoder(get(context, Decoder.class))<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.contract(get(context, Contract.class));</p> <p> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 对 builder 进行其他属性设置<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;configureFeign(context, builder);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return builder;<br /> &nbsp;&nbsp; &nbsp;}</p> <p> 方法FeignClientFactoryBean#loadBalance – 生成具备负载均衡能力的feign客户端<br /> 为feign客户端构建器绑定负载均衡客户端,绑定目标服务端点，并生成最终的feign客户端实例。</p> <p>// 对builder设置负载均衡客户端，绑定到目标服务端点，构建最终的feign客户端对象<br /> protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HardCodedTarget&lt;T&gt; target) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从上下文context获取一个Client，缺省是 LoadBalancerFeignClient<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Client client = getOptional(context, Client.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (client != null) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 将client设置到builder上<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.client(client);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从上下文中获取一个 targeter,缺省是一个 HystrixTargeter<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Targeter targeter = get(context, Targeter.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 上面获取得到的 targeter 会根据 builder 的类型决定如何将 target<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 绑定到 builder 并设置有关的其他属性和功能,然后生成最终的feign客户端对象<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return targeter.target(this, builder, context, target);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new IllegalStateException(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"No Feign Client for loadBalancing defined. Did you forget to include " +<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"spring-cloud-starter-netflix-ribbon?");<br /> &nbsp;&nbsp; &nbsp;}</p> <p> 从上面分析可以看出，缺省情况下，所使用的feign客户端构建器类为Feign.Builder,并且Targeter是一个HystrixTargeter。HystrixTargeter#target方法的参数builder为Feign.Builder时，会直接调用该builder的target方法,如下所示 ：</p> <p>class HystrixTargeter implements Targeter {<!-- --><br /> @Override<br /> &nbsp;&nbsp; &nbsp;public &lt;T&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Target.HardCodedTarget&lt;T&gt; target) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!(feign instanceof feign.hystrix.HystrixFeign.Builder)) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return feign.target(target);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp; &nbsp; &nbsp; &nbsp;// ... 省略其他代码<br /> &nbsp;&nbsp; &nbsp;}<br /> }</p> <p> 接下来再来看Feign.Builder#target是如何工作的:</p> <p>&nbsp; // 执行构建并且创建相应的feign客户端实例<br /> &nbsp; public &lt;T&gt; T target(Target&lt;T&gt; target) {<!-- --><br /> &nbsp; &nbsp; &nbsp; return build().newInstance(target);<br /> &nbsp; &nbsp; }</p> <p> &nbsp; // 构建过程，最终根据各种配置生成一个 ReflectiveFeign 对象<br /> &nbsp; public Feign build() {<!-- --><br /> &nbsp; &nbsp; &nbsp; SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logLevel, decode404, closeAfterDecode, propagationPolicy);<br /> &nbsp; &nbsp; &nbsp; ParseHandlersByName handlersByName =<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errorDecoder, synchronousMethodHandlerFactory);<br /> &nbsp; &nbsp; &nbsp; return new ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);<br /> &nbsp; &nbsp; }<br /> &nbsp; }</p> <p> 然后再看ReflectiveFeign#newInstance方法:</p> <p>&nbsp; // 创建最终的feign客户端实例 : 一个 ReflectiveFeign$FeignInvocationHandler 的动态代理对象<br /> &nbsp; @Override<br /> &nbsp; public &lt;T&gt; T newInstance(Target&lt;T&gt; target) {<!-- --><br /> &nbsp; &nbsp; Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);<br /> &nbsp; &nbsp; Map&lt;Method, MethodHandler&gt; methodToHandler = new LinkedHashMap&lt;Method, MethodHandler&gt;();<br /> &nbsp; &nbsp; List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = new LinkedList&lt;DefaultMethodHandler&gt;();</p> <p>&nbsp; &nbsp; for (Method method : target.type().getMethods()) {<!-- --><br /> &nbsp; &nbsp; &nbsp; if (method.getDeclaringClass() == Object.class) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /> &nbsp; &nbsp; &nbsp; } else if (Util.isDefault(method)) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;// 对于每个缺省方法，使用 DefaultMethodHandler<br /> &nbsp; &nbsp; &nbsp; &nbsp; DefaultMethodHandler handler = new DefaultMethodHandler(method);<br /> &nbsp; &nbsp; &nbsp; &nbsp; defaultMethodHandlers.add(handler);<br /> &nbsp; &nbsp; &nbsp; &nbsp; methodToHandler.put(method, handler);<br /> &nbsp; &nbsp; &nbsp; } else {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;// 对于每个对应服务功能端点的方法，缺省使用nameToHandler获取的MethodHandler，缺省是<br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;// SynchronousMethodHandler<br /> &nbsp; &nbsp; &nbsp; &nbsp; methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));<br /> &nbsp; &nbsp; &nbsp; }<br /> &nbsp; &nbsp; }<br /> &nbsp; &nbsp; // 创建feign客户端实例 ReflectiveFeign$FeignInvocationHandler,<br /> &nbsp; &nbsp; // 该对象包含了上面所创建的methodToHandler，用于对应各个开发者定义的@FeignClient接口方法<br /> &nbsp; &nbsp; InvocationHandler handler = factory.create(target, methodToHandler);<br /> &nbsp; &nbsp; // 创建feign客户端实例的动态代理对象<br /> &nbsp; &nbsp; T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),<br /> &nbsp; &nbsp; &nbsp; &nbsp; new Class&lt;?&gt;[] {target.type()}, handler);</p> <p>&nbsp;&nbsp; &nbsp;// 将缺省方法处理器绑定到feign客户端实例的动态代理对象上<br /> &nbsp; &nbsp; for (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {<!-- --><br /> &nbsp; &nbsp; &nbsp; defaultMethodHandler.bindTo(proxy);<br /> &nbsp; &nbsp; }<br /> &nbsp; &nbsp; return proxy;<br /> &nbsp; }<br /> 从上面的分析我们不难看出，为什么最终注入的testService最终是一个ReflectiveFeign$FeignInvocationHandler动态代理实例了。</p> <p>总结<br /> 从上面的分析可以看出，当我们使用注解@EnableFeignClients 时，相当于启用了feign客户端定义的扫描和注册机制，从而可以发现开发人员通过注解@FeignClient定义的feign客户端，并最终作为bean定义注册到容器中。而通过@Autowired自动装配注解，这些feign客户端会以ReflectiveFeign$FeignInvocationHandler动态代理的形式被注入到使用方。该feign客户端包含了对每个接口方法的处理器MethodHandler,接口缺省方法对应DefaultMethodHandler,服务功能端点方法对应SynchronousMethodHandler。</p> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-72060.htm">Maven配置及IDEA中配置Maven详解</a></p>
                                    </div>
                                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-54007.htm" title="国内宠物粮食十大厂家排名（中国宠物粮厂家批发网）">国内宠物粮食十大厂家排名（中国宠物粮厂家批发网）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-26-node-share-links.htm" title="2月26日21.2M/S|Shadowrocket/Clash/SSR/V2ray免费节点每天更新订阅链接地址分享">2月26日21.2M/S|Shadowrocket/Clash/SSR/V2ray免费节点每天更新订阅链接地址分享</a></li>
                        <li class="py-2"><a href="/news/article-37880.htm" title="动物美容院（动物美容院的工具）">动物美容院（动物美容院的工具）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-14-free-shadowrocket-node.htm" title="2月14日22.2M/S|V2ray/SSR/Clash/Shadowrocket免费节点每天更新订阅链接地址分享">2月14日22.2M/S|V2ray/SSR/Clash/Shadowrocket免费节点每天更新订阅链接地址分享</a></li>
                        <li class="py-2"><a href="/news/article-45813.htm" title="瑞鹏宠物医院联系电话（瑞鹏宠物医院客服电话）">瑞鹏宠物医院联系电话（瑞鹏宠物医院客服电话）</a></li>
                        <li class="py-2"><a href="/news/article-70738.htm" title="狗粮的十大品牌是哪几个品牌（狗粮十大品牌排行榜介绍）">狗粮的十大品牌是哪几个品牌（狗粮十大品牌排行榜介绍）</a></li>
                        <li class="py-2"><a href="/news/article-56775.htm" title="动物疫苗厂家（动物疫苗厂家有哪些）">动物疫苗厂家（动物疫苗厂家有哪些）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-13-clash-node.htm" title="2月13日22.1M/S|Shadowrocket/Clash/SSR/V2ray免费节点每天更新订阅链接地址分享">2月13日22.1M/S|Shadowrocket/Clash/SSR/V2ray免费节点每天更新订阅链接地址分享</a></li>
                        <li class="py-2"><a href="/news/article-49784.htm" title="关于CSS样式的优先级问题">关于CSS样式的优先级问题</a></li>
                        <li class="py-2"><a href="/news/article-42337.htm" title="上海宠物领养平台电话（上海2020年宠物领养活动）">上海宠物领养平台电话（上海2020年宠物领养活动）</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">36</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                    </ul>
    </div>
</div>


                </div>
            </div>
        </div>
    </div>
    <!-- End Blog -->
        <!-- Star Footer
    ============================================= -->
    <footer class="bg-dark text-light">
        <!-- Footer Bottom -->
        <div class="footer-bottom">
            <div class="container">
                <div class="row">
                    <div class="col-lg-6">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                        <p>
                            NodeClash节点订阅站 版权所有
                            <br />
                            Powered by WordPress
                        </p>
                    </div>
                    <div class="col-lg-6 text-right link">
                        <ul>
                            <li>
                                <a href="#">Terms</a>
                            </li>
                            <li>
                                <a href="#">Privacy</a>
                            </li>
                            <li>
                                <a href="#">Support</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Footer Bottom -->
    </footer>
    <!-- End Footer-->

    <!-- jQuery Frameworks
    ============================================= -->
    <script src="/assets/website/js/frontend/nodeclash/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/popper.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/bootstrap.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/jquery.appear.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/jquery.easing.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/jquery.magnific-popup.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/modernizr.custom.13711.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/owl.carousel.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/wow.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/progress-bar.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/isotope.pkgd.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/imagesloaded.pkgd.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/count-to.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/YTPlayer.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/jquery.nice-select.min.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/loopcounter.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/bootsnav.js"></script>
    <script src="/assets/website/js/frontend/nodeclash/main.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>